<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galleon Serial FPDP Recorder - Control API: GEC_ISfpdpRecorder Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galleon Serial FPDP Recorder - Control API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGEC__ISfpdpRecorder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GEC_ISfpdpRecorder Interface Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="GEC__ISfpdpRecorder_8h_source.html">GEC_ISfpdpRecorder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc3a0ead7f8e0b4b643ba2053ecfa2b7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#adc3a0ead7f8e0b4b643ba2053ecfa2b7">setIntChannelSyncControl</a> (int mode)=0</td></tr>
<tr class="separator:adc3a0ead7f8e0b4b643ba2053ecfa2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae328a49755417e0a594b1c4751125e10"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#ae328a49755417e0a594b1c4751125e10">setIntChannelSync</a> (uint32_t iDevice, int masterMask, int action)=0</td></tr>
<tr class="separator:ae328a49755417e0a594b1c4751125e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5045086449aac437f22e84e7f943bfd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#ab5045086449aac437f22e84e7f943bfd">setChannelSyncOutput</a> (uint32_t iDevice, int signal, int source)=0</td></tr>
<tr class="separator:ab5045086449aac437f22e84e7f943bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad99a60dd9780de5336dbc5f50ce5f5c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#aad99a60dd9780de5336dbc5f50ce5f5c">reset</a> ()=0</td></tr>
<tr class="separator:aad99a60dd9780de5336dbc5f50ce5f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7630972b174f6c4e23e3f2db84cc681"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create</a> (std::string path, std::string name, uint32_t iDevice, uint32_t iPort, uint32_t &amp;id)=0</td></tr>
<tr class="separator:ad7630972b174f6c4e23e3f2db84cc681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3e83188a253e7699170c10382a2b8f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open</a> (std::string path, std::string name, uint32_t iDevice, uint32_t iPort, int mode, uint32_t &amp;id)=0</td></tr>
<tr class="separator:a7b3e83188a253e7699170c10382a2b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110939fb83085e75141173a57057c082"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a110939fb83085e75141173a57057c082">destroy</a> (uint32_t id)=0</td></tr>
<tr class="separator:a110939fb83085e75141173a57057c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc21308306dc6afe6e57f589f33a1d55"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#afc21308306dc6afe6e57f589f33a1d55">setCRC</a> (uint32_t id, bool enableCRC)=0</td></tr>
<tr class="separator:afc21308306dc6afe6e57f589f33a1d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70152e99cd5141e964d6d1882ed22423"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a70152e99cd5141e964d6d1882ed22423">setCopyMode</a> (uint32_t id, bool enable)=0</td></tr>
<tr class="separator:a70152e99cd5141e964d6d1882ed22423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248d5ce7dce0c13c2ea6893b2afd11a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a2248d5ce7dce0c13c2ea6893b2afd11a">setWaitForSync</a> (uint32_t id, int mode)=0</td></tr>
<tr class="separator:a2248d5ce7dce0c13c2ea6893b2afd11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118285ec2027c4ef0a8fc061d3a7cacb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a118285ec2027c4ef0a8fc061d3a7cacb">setMaxSize</a> (uint32_t id, uint64_t sizeInBytes)=0</td></tr>
<tr class="separator:a118285ec2027c4ef0a8fc061d3a7cacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5124cdb69132a21e7645014b13881701"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a5124cdb69132a21e7645014b13881701">setLinkSpeed</a> (uint32_t id, int speed)=0</td></tr>
<tr class="separator:a5124cdb69132a21e7645014b13881701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2627c35feb86e78dff1a71946cf018c2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a2627c35feb86e78dff1a71946cf018c2">setFlowControl</a> (uint32_t id, bool enable)=0</td></tr>
<tr class="separator:a2627c35feb86e78dff1a71946cf018c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3575333a82b60b4bc8a51306ea5a789"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#ac3575333a82b60b4bc8a51306ea5a789">setRateControl</a> (uint32_t id, int cycleSize, uint32_t cyclePartsForTx)=0</td></tr>
<tr class="separator:ac3575333a82b60b4bc8a51306ea5a789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0485d7050c4d8425db947c8f306228d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#ac0485d7050c4d8425db947c8f306228d">setSimplexLinkMode</a> (uint32_t id, bool enable)=0</td></tr>
<tr class="separator:ac0485d7050c4d8425db947c8f306228d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c1e6b523f50b1f584a6eede392ddf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a887c1e6b523f50b1f584a6eede392ddf">setChannelSyncSource</a> (uint32_t id, int source)=0</td></tr>
<tr class="separator:a887c1e6b523f50b1f584a6eede392ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8defdd82514e1012e7beb95e9da33ccf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a8defdd82514e1012e7beb95e9da33ccf">setSwapping</a> (uint32_t id, bool enable8in16, bool enable16in32)=0</td></tr>
<tr class="separator:a8defdd82514e1012e7beb95e9da33ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afafc85862dbf642aa03506f6462a8b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a7afafc85862dbf642aa03506f6462a8b">getStatus</a> (uint32_t id, uint64_t &amp;numBytes, std::string &amp;state)=0</td></tr>
<tr class="separator:a7afafc85862dbf642aa03506f6462a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fce65de325a62852e78a7d49b077e1b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a6fce65de325a62852e78a7d49b077e1b">checkForOverflow</a> (uint32_t id, bool &amp;detected, bool clear)=0</td></tr>
<tr class="separator:a6fce65de325a62852e78a7d49b077e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c66f4c6013aeace6f6f117a9a0329"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll</a> ()=0</td></tr>
<tr class="separator:a8f3c66f4c6013aeace6f6f117a9a0329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1055aa473a5e0348d3a6cc8856a59e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGEC__ISfpdpRecorder.html#abb1055aa473a5e0348d3a6cc8856a59e">stopAll</a> ()=0</td></tr>
<tr class="separator:abb1055aa473a5e0348d3a6cc8856a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface representing the API available for remote control of SFPDP recording. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#_a1">example.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6fce65de325a62852e78a7d49b077e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fce65de325a62852e78a7d49b077e1b">&#9670;&nbsp;</a></span>checkForOverflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::checkForOverflow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if overflow has occurred in a recording session</p>
<p>The boolean reference 'detected' returns the overflow state of the specified session. Its value is 'true' if one or more overflows has been detected since the last time the overflow state was cleared.</p>
<p>The overflow state is cleared when recording is started (<a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a>), and when this function exits, if it is called with the <code>clear</code> argument set to 'true'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the recorder session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>). </td></tr>
    <tr><td class="paramname">detected</td><td>boolean reference that states whether or not overflows have been detected </td></tr>
    <tr><td class="paramname">clear</td><td>boolean flag which states whether the overflow state should be cleared when this function returns</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing recording session </dd></dl>

</div>
</div>
<a id="ad7630972b174f6c4e23e3f2db84cc681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7630972b174f6c4e23e3f2db84cc681">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::create </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new recording session</p>
<p>When the session is started (see <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a>), data from a given SFPDP channel are stored into a data file.</p>
<p>The recorder also produces an index file and a meta data file for each session. The index file will store information about events that occur during the recording session, such as reception of SYNC and detection of CRC errors. The meta data file contains timing information which the recorder can use to play back the data.</p>
<p>The three files associated with a recording session will be created in the folder specified by the 'path' parameter. Their file basenames are given by the 'name' parameter. File extensions '.dat', '.idx', and '.meta' will be used for respectively the data file, the index file, and the meta data file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>String with the full name of the directory where the files associated with the recording will be stored </td></tr>
    <tr><td class="paramname">name</td><td>String with the base name of the recording </td></tr>
    <tr><td class="paramname">iDevice</td><td>32 bit integer giving the index of the SFPDP device to use. Most systems have only one device, so this value is usually 0. </td></tr>
    <tr><td class="paramname">iPort</td><td>32 bit integer giving the index of the SFPDP port to use. This value is the same as the port number on the corresponding front panel label. </td></tr>
    <tr><td class="paramname">id</td><td>32 bit integer reference which returns an unique value representing the recording session</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_FILE_IN_USE The value of 'name' is already in use as base name in 'path' by another recording session </dd>
<dd>
GE_BUSY The given device and channel index pair is already assigned to another recording session </dd>
<dd>
GE_NOT_EXISTING The given device and channel index pair doesn't refer to any physical device </dd>
<dd>
GE_NO_ACCESS Recording files cannot be created in the directory specified by the path parameter </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a4">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a110939fb83085e75141173a57057c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110939fb83085e75141173a57057c082">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::destroy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy a session</p>
<p>The associated files will not be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing a recording session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>) or a playback session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing session </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a8">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a7afafc85862dbf642aa03506f6462a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afafc85862dbf642aa03506f6462a8b">&#9670;&nbsp;</a></span>getStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::getStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get status of a session</p>
<p>The reference parameter 'state' returns the state of a session as a string.</p>
<p>A recording session may return the following state strings:</p>
<ul>
<li>'Ready' means that the session is waiting for the <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> method to be called.</li>
<li>'Recording' means that the <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> method is called</li>
<li>'Idle' means that the <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> method is called, but the recording session hasn't received new data the last 5 seconds.</li>
<li>'Maxed out' means that the data file of this recording session has recorded the amount of data specified by <a class="el" href="classGEC__ISfpdpRecorder.html#a118285ec2027c4ef0a8fc061d3a7cacb">setMaxSize()</a>, and further data is not stored.</li>
<li>'Stopped' means that the <a class="el" href="classGEC__ISfpdpRecorder.html#abb1055aa473a5e0348d3a6cc8856a59e">stopAll()</a> method is called and further data is not recorded.</li>
</ul>
<p>A playback session may return the following state strings:</p>
<ul>
<li>'Ready' means that the session is waiting for the <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> method to be called.</li>
<li>'Playing' means that the <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> method is called.</li>
<li>'Stopped' means the session has stopped transmitting data because the <a class="el" href="classGEC__ISfpdpRecorder.html#abb1055aa473a5e0348d3a6cc8856a59e">stopAll()</a> method has been called.</li>
<li>'End of file' means the session has read all data from file, but some of it is still waiting to be transmitted.</li>
<li>'All data transmitted' means that the session has transmitted all its data.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing a recording session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>) or a playback session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open()</a>). </td></tr>
    <tr><td class="paramname">numBytes</td><td>64 bit unsigned integer reference returning a number of bytes. For a recording session this is the number of recorded bytes, and for a playback session this is the number of played bytes. </td></tr>
    <tr><td class="paramname">state</td><td>String reference returning the state of the session. The possible states for recording sessions are 'Ready', 'Recording', 'Idle', 'Maxed out', and 'Stopped'. And the possible states for playback sessions are 'Ready', 'Playing', 'Stopped', and 'End of file'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing session </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a6">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a7b3e83188a253e7699170c10382a2b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3e83188a253e7699170c10382a2b8f">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::open </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a new playback session</p>
<p>A playback session will always use a data file, and it may use a metadata file. The basename of both files is specified by the 'name' parameter, and both must be located in the folder specified by the 'path' parameter. The two files are distinguished by their file extension - the data file has a '.dat' extension and the metadata file has a '.meta' extension.</p>
<p>When the session is started (see <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a>), data from a data file is played back to the Serial FPDP port specified by the 'iDevice' and 'iPort' parameters.</p>
<p>The 'mode' parameter specifies how the recorder will handle SYNC, DIR, PIO1, and PIO2 signaling:</p>
<ul>
<li>if 'mode' is <a class="el" href="GEC__ISfpdpRecorder_8h.html#ad644561c8e129e83b490571eed267bf4">GEC_SFPDP_PLAYBACK_WITHOUT_SIGNALS</a>, the data will be played back as fast as possible without signaling (all signals are deasserted during playback).</li>
<li>if 'mode' is <a class="el" href="GEC__ISfpdpRecorder_8h.html#a4e1bd64b040adaa9344681a6608e5072">GEC_SFPDP_PLAYBACK_WITH_UNTIMED_SIGNALS</a>, the recorder regenerates the state changes of the signals relative to the recorded data words. But the timing of the recorded signals are not preserved - the data words are just transmitted as fast as possible.</li>
<li>if 'mode' is <a class="el" href="GEC__ISfpdpRecorder_8h.html#aec038db94b8097fcf9fede91f4ba7e59">GEC_SFPDP_PLAYBACK_WITH_TIMED_SIGNALS</a>, the recorder regenerates the state changes of the signals relative to the recorded timing information. This means that the playback will be paced in order to resemble the timing of the recorded data flow.</li>
</ul>
<p>A playback session requires a meta data file in order to regenerate signaling (<a class="el" href="GEC__ISfpdpRecorder_8h.html#a4e1bd64b040adaa9344681a6608e5072">GEC_SFPDP_PLAYBACK_WITH_UNTIMED_SIGNALS</a> or <a class="el" href="GEC__ISfpdpRecorder_8h.html#aec038db94b8097fcf9fede91f4ba7e59">GEC_SFPDP_PLAYBACK_WITH_TIMED_SIGNALS</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>String with the full name of the folder where the files associated with the playback session are stored </td></tr>
    <tr><td class="paramname">name</td><td>String with the base name of the data file and the meta data file </td></tr>
    <tr><td class="paramname">iDevice</td><td>32 bit integer giving the index of the SFPDP device to use. Most systems have only one device, so this value is 0. </td></tr>
    <tr><td class="paramname">iPort</td><td>32 bit integer giving the index of the SFPDP port to use. This value is the same as the port number on the corresponding front panel label. </td></tr>
    <tr><td class="paramname">mode</td><td>integer whose value is <a class="el" href="GEC__ISfpdpRecorder_8h.html#ad644561c8e129e83b490571eed267bf4">GEC_SFPDP_PLAYBACK_WITHOUT_SIGNALS</a>, <a class="el" href="GEC__ISfpdpRecorder_8h.html#a4e1bd64b040adaa9344681a6608e5072">GEC_SFPDP_PLAYBACK_WITH_UNTIMED_SIGNALS</a>, or <a class="el" href="GEC__ISfpdpRecorder_8h.html#aec038db94b8097fcf9fede91f4ba7e59">GEC_SFPDP_PLAYBACK_WITH_TIMED_SIGNALS</a> </td></tr>
    <tr><td class="paramname">id</td><td>32 bit integer reference which returns an unique value representing the playback session</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_FILE_IN_USE The specified values for 'name' and 'path' are already in use as basename and folder in a recording session </dd>
<dd>
GE_BUSY The given device index and channel index pair is already assigned to another playback session </dd>
<dd>
GE_NOT_EXISTING The given device index and channel index pair doesn't refer to any physical device </dd>
<dd>
GE_NO_ACCESS The files required for playback are not accessible </dd></dl>

</div>
</div>
<a id="aad99a60dd9780de5336dbc5f50ce5f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad99a60dd9780de5336dbc5f50ce5f5c">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset recorder</p>
<p>This method will first stop all active sessions, and then delete all existing sessions.</p>
<p>Applications that use this interface should call reset on startup.</p>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a3">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab5045086449aac437f22e84e7f943bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5045086449aac437f22e84e7f943bfd">&#9670;&nbsp;</a></span>setChannelSyncOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setChannelSyncOutput </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the source that drives an external channel sync output signal</p>
<p>This method is only applicable to SFPDP recorder systems that provide an external channel sync output signal. On these system this method is called to configure what source should drive the output signal.</p>
<p>The output signal is specified by the <code>iDevice</code> argument specifying the SFPDP module, and the <code>signal</code> argument specifying the ID of one of the external signals:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Signal ID  </th><th class="markdownTableHeadRight">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a4fae15b6d6f766d1c327229262563351">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT0</a>  </td><td class="markdownTableBodyRight">EXT0 Coax Output   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a76e90540844fec6c37dc2f85ab62b14f">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT1</a>  </td><td class="markdownTableBodyRight">EXT1 Coax Output   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a42acf2adebf169370500c017c9b012ff">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT2</a>  </td><td class="markdownTableBodyRight">EXT2 Coax Output   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a36673424d169d10f698b189e5382e581">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT3</a>  </td><td class="markdownTableBodyRight">EXT3 Coax Output   </td></tr>
</table>
<p>The source that shall drive the output signal is specified by the <code>source</code> argument whose value is the ID of an internal master or an external input:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Source ID  </th><th class="markdownTableHeadRight">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a585c9352e53cb508c0943a1705fae79d">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_0</a>  </td><td class="markdownTableBodyRight">Internal Master 0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#ac4662a0998edd828a12208a454cc0182">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_1</a>  </td><td class="markdownTableBodyRight">Internal Master 1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#af1322bdff7cf4104d12f20fe5140a1b2">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_2</a>  </td><td class="markdownTableBodyRight">Internal Master 2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a664b1be5bf7edca4f80e983813818e18">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_3</a>  </td><td class="markdownTableBodyRight">Internal Master 3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a4fae15b6d6f766d1c327229262563351">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT0</a>  </td><td class="markdownTableBodyRight">EXT0 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a76e90540844fec6c37dc2f85ab62b14f">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT1</a>  </td><td class="markdownTableBodyRight">EXT1 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a42acf2adebf169370500c017c9b012ff">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT2</a>  </td><td class="markdownTableBodyRight">EXT2 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a36673424d169d10f698b189e5382e581">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT3</a>  </td><td class="markdownTableBodyRight">EXT3 Coax Input   </td></tr>
</table>
<p>By default Internal Master 0 is used to drive an external channel sync output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDevice</td><td>32 bit integer giving the index of the SFPDP device to use. Most systems have only one device, so this value is usually 0. </td></tr>
    <tr><td class="paramname">signal</td><td>integer whose value is one of the 4 IDs for external channel sync signals </td></tr>
    <tr><td class="paramname">source</td><td>integer whose value is one of the 8 IDs for channel sync signal source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of <code>signal</code> isn't the ID of an external master or the value of <code>source</code> isn't the ID of a source </dd>
<dd>
GE_NOT_PERMITTED The specified signal isn't routed to an connector. </dd>
<dd>
GE_NOT_EXISTING The given device index doesn't refer to a physical device </dd></dl>

</div>
</div>
<a id="a887c1e6b523f50b1f584a6eede392ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c1e6b523f50b1f584a6eede392ddf">&#9670;&nbsp;</a></span>setChannelSyncSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setChannelSyncSource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select the source for the channel sync signal</p>
<p>The recorder uses HW timers to generate the timing information which is stored in the metadata files during recording sessions. During playback sessions, the same timers can be used to recreate the timing of SYNC, PIO1, PIO2, and DIR signaling.</p>
<p>A channel sync signal is used to synchronize the HW timers of different SFPDP ports. This signal is a 5MHz clock signal which is either generated internally or taken from an exernal source.</p>
<p>This method selects which channel sync source to be used by the session specified by the <code>id</code> argument.</p>
<p>When the recorder is configured to automatically control the internal channel sync masters (see <a class="el" href="classGEC__ISfpdpRecorder.html#adc3a0ead7f8e0b4b643ba2053ecfa2b7">setIntChannelSyncControl()</a>), only one internal master - Internal Master 0 - can be selected as channel sync source. In addition external channal sync signals can be selected, if they are supported by the hardware configuration. The following table summarize the valid values for the <code>source</code> argument:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Source ID  </th><th class="markdownTableHeadRight">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a585c9352e53cb508c0943a1705fae79d">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_0</a>  </td><td class="markdownTableBodyRight">Internal Master 0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a4fae15b6d6f766d1c327229262563351">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT0</a>  </td><td class="markdownTableBodyRight">EXT0 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a76e90540844fec6c37dc2f85ab62b14f">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT1</a>  </td><td class="markdownTableBodyRight">EXT1 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a42acf2adebf169370500c017c9b012ff">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT2</a>  </td><td class="markdownTableBodyRight">EXT2 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a36673424d169d10f698b189e5382e581">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT3</a>  </td><td class="markdownTableBodyRight">EXT3 Coax Input   </td></tr>
</table>
<p>When the recorder is configured to let the internal masters be controlled through the control API, all four internal masters are valid sources. The following table shows the IDs, that are valid values for the <code>source</code> argument in this mode:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Source ID  </th><th class="markdownTableHeadRight">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a585c9352e53cb508c0943a1705fae79d">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_0</a>  </td><td class="markdownTableBodyRight">Internal Master 0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#ac4662a0998edd828a12208a454cc0182">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_1</a>  </td><td class="markdownTableBodyRight">Internal Master 1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#af1322bdff7cf4104d12f20fe5140a1b2">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_2</a>  </td><td class="markdownTableBodyRight">Internal Master 2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a664b1be5bf7edca4f80e983813818e18">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_3</a>  </td><td class="markdownTableBodyRight">Internal Master 3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a4fae15b6d6f766d1c327229262563351">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT0</a>  </td><td class="markdownTableBodyRight">EXT0 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a76e90540844fec6c37dc2f85ab62b14f">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT1</a>  </td><td class="markdownTableBodyRight">EXT1 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a42acf2adebf169370500c017c9b012ff">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT2</a>  </td><td class="markdownTableBodyRight">EXT2 Coax Input   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a36673424d169d10f698b189e5382e581">GEC_SFPDP_EXTERNAL_CHANNEL_SYNC_EXT3</a>  </td><td class="markdownTableBodyRight">EXT3 Coax Input   </td></tr>
</table>
<p>When the source of the channel sync signal is one of the internal masters, generation of the signal can either be started automatically by the recorder or manually through the API (see <a class="el" href="classGEC__ISfpdpRecorder.html#adc3a0ead7f8e0b4b643ba2053ecfa2b7">setIntChannelSyncControl()</a> and <a class="el" href="classGEC__ISfpdpRecorder.html#ae328a49755417e0a594b1c4751125e10">setIntChannelSync()</a>).</p>
<p>Support for external channel sync signals is an optional feature that most SFPDP recorders do not have. On these systems without external channel sync signals, Internal Master 0 will usually be the channel sync signal source in all sessions.</p>
<p>On recorders with support for external channel sync, please refer to the approriate ICD for details on signal routing from the connectors.</p>
<p>By default the source of the channel sync signal is Internal Master 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing a recording session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>) or a playback session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open()</a>). </td></tr>
    <tr><td class="paramname">source</td><td>integer whose value is one of the 8 IDs for channel sync signal source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of <code>id</code> doesn't refer to an existing session, or the value of <code>source</code> doesn't refer to a source </dd>
<dd>
GE_NOT_PERMITTED The source selected by <code>source</code> isn't available </dd></dl>

</div>
</div>
<a id="a70152e99cd5141e964d6d1882ed22423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70152e99cd5141e964d6d1882ed22423">&#9670;&nbsp;</a></span>setCopyMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setCopyMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether Copy Mode is enabled or not.</p>
<p>This method can only be called for recording sessions. When called with the 'enable' parameter equal to true, the associated Serial FPDP port will start transmitting copies of all Serial FPDP frames it receives.</p>
<p>Copy Mode and Playback are mutally exclusive. Therefore this method will fail if the associated Serial FPDP port is already used in a playback session.</p>
<p>This method will have effect immediately when called for a recording session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the recording session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>). </td></tr>
    <tr><td class="paramname">enable</td><td>boolean value which states whether Copy Mode is enabled (true) or disabled (false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing recording session </dd>
<dd>
GE_NOT_PERMITTED The selected session is a playback session, or the Serial FPDP port of the selected session is already used by a playback session </dd></dl>

</div>
</div>
<a id="afc21308306dc6afe6e57f589f33a1d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc21308306dc6afe6e57f589f33a1d55">&#9670;&nbsp;</a></span>setCRC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setCRC </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableCRC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether CRC handling is enabled or not.</p>
<p>When CRC handling is enabled for a recording session, the recorder expects all serial FPDP frames received on the associated port to contain a CRC word. The recorder validates the value of all these CRC words. If an error is detected, the recorder adds an CRC Error entry in the index file. The data associated with an incorrect CRC, is stored in the data file as usually.</p>
<p>When CRC handling is enabled for a playback session, the recorder will insert a CRC in each Serial FPDP frame it transmits on the associated port.</p>
<p>To have effect, this method must be called while the recorder instance is inactive (before <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll</a> is called).</p>
<p>By default CRC handling is disabled both for recording and playback sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a> or <a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open()</a>). </td></tr>
    <tr><td class="paramname">enableCRC</td><td>boolean value which states whether CRC checking/generation is enabled (true) or disabled (false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing recorder instance </dd></dl>

</div>
</div>
<a id="a2627c35feb86e78dff1a71946cf018c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2627c35feb86e78dff1a71946cf018c2">&#9670;&nbsp;</a></span>setFlowControl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setFlowControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether flow control is enabled or not.</p>
<p>When called with the 'enable' parameter equal to true, this method enables flow control for the specified session. And when called with the 'enable' parameter equal to false, it disables flow control.</p>
<p>When flow control is enabled for a recording session, STOP ordered sets will be transmitted from the Serial FPDP port when the receive FIFO is almost full.</p>
<p>When flow control is enabled for a playback session, the recorder will stop transmitting data when it receives a STOP ordered set from the other end. Data transmission is resumed when a GO ordered set is received.</p>
<p>To have effect, this method must be called while the recorder instance is inactive (before <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll</a> is called).</p>
<p>By default flow control is enabled both for recording and playback sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a> or <a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open()</a>). </td></tr>
    <tr><td class="paramname">enable</td><td>boolean value which states whether flow control is enabled (true) or disabled (false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing recorder instance </dd></dl>

</div>
</div>
<a id="ae328a49755417e0a594b1c4751125e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae328a49755417e0a594b1c4751125e10">&#9670;&nbsp;</a></span>setIntChannelSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setIntChannelSync </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>masterMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set state of internal channel sync generation</p>
<p>This method is called to start, pause, or stop signal generation on one or more internal channel sync masters on the SFPDP module identified by the <code>iDevice</code> argument. The constants in the table below are used to identify the internal masters in the <code>masterMask</code> argument. Multiple masters are selected, by bitwise ORing together the corresponding constants in the <code>masterMask</code> argument.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Source ID  </th><th class="markdownTableHeadRight">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a585c9352e53cb508c0943a1705fae79d">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_0</a>  </td><td class="markdownTableBodyRight">Internal Master 0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#ac4662a0998edd828a12208a454cc0182">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_1</a>  </td><td class="markdownTableBodyRight">Internal Master 1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#af1322bdff7cf4104d12f20fe5140a1b2">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_2</a>  </td><td class="markdownTableBodyRight">Internal Master 2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a664b1be5bf7edca4f80e983813818e18">GEC_SFPDP_INTERNAL_CHANNEL_SYNC_MASTER_3</a>  </td><td class="markdownTableBodyRight">Internal Master 3   </td></tr>
</table>
<p>Prior to calling this method, the recorder must have been configured to use manual control for the internal channel sync masters (see <a class="el" href="classGEC__ISfpdpRecorder.html#adc3a0ead7f8e0b4b643ba2053ecfa2b7">setIntChannelSyncControl()</a>).</p>
<p>Signal generation from the selected masters is activated, when this method is called with <a class="el" href="GEC__ISfpdpRecorder_8h.html#a35b8163478889ff7356e0230c8023b00">GEC_SFPDP_START_CHANNEL_SYNC</a> as the 'action' parameter. And it is paused or stopped when this method is called with respectively <a class="el" href="GEC__ISfpdpRecorder_8h.html#a38b19e370ea88a989c46c2aa186b717c">GEC_SFPDP_PAUSE_CHANNEL_SYNC</a> or <a class="el" href="GEC__ISfpdpRecorder_8h.html#a32c74d676d4e38168fdd33ccfb93309a">GEC_SFPDP_STOP_CHANNEL_SYNC</a> as the <code>action</code> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDevice</td><td>32 bit integer giving the index of the SFPDP device to use. Most systems have only one device, so this value is usually 0. </td></tr>
    <tr><td class="paramname">masterMask</td><td>integer whose value is one internal channel sync master ID or a bitwise combination of several IDs </td></tr>
    <tr><td class="paramname">action</td><td>integer whose value is <a class="el" href="GEC__ISfpdpRecorder_8h.html#a35b8163478889ff7356e0230c8023b00">GEC_SFPDP_START_CHANNEL_SYNC</a>, <a class="el" href="GEC__ISfpdpRecorder_8h.html#a38b19e370ea88a989c46c2aa186b717c">GEC_SFPDP_PAUSE_CHANNEL_SYNC</a>, or <a class="el" href="GEC__ISfpdpRecorder_8h.html#a32c74d676d4e38168fdd33ccfb93309a">GEC_SFPDP_STOP_CHANNEL_SYNC</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The <code>masterMask</code> argument represents at least one ID that doesn't belong to an internal master </dd>
<dd>
GE_NOT_PERMITTED Manual control of internal channel sync masters is not enabled </dd>
<dd>
GE_NOT_EXISTING The given device index doesn't refer to a physical device </dd></dl>

</div>
</div>
<a id="adc3a0ead7f8e0b4b643ba2053ecfa2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3a0ead7f8e0b4b643ba2053ecfa2b7">&#9670;&nbsp;</a></span>setIntChannelSyncControl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setIntChannelSyncControl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set control mode for all internal channel sync masters</p>
<p>This method configures how the internal channel sync masters are controlled.</p>
<p>If the <code>mode</code> argument has the value <a class="el" href="GEC__ISfpdpRecorder_8h.html#a30e33cb73966e64469d0ee06fcfcee2d">GEC_SFPDP_AUTOMATIC_CONTROL</a>, <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> implicitly starts signal generation on all internal masters that one or more sessions are configured to use (see <a class="el" href="classGEC__ISfpdpRecorder.html#a887c1e6b523f50b1f584a6eede392ddf">setChannelSyncSource()</a>). In this mode, it is not possible to pause the signal generation.</p>
<p>If the <code>mode</code> argument has the value <a class="el" href="GEC__ISfpdpRecorder_8h.html#a9fc53ab19e2da7d37577ed0739d28aa2">GEC_SFPDP_MANUAL_CONTROL</a>, the signal generation on all internal channel sync masters has to be explictly started by calling <a class="el" href="classGEC__ISfpdpRecorder.html#ae328a49755417e0a594b1c4751125e10">setIntChannelSync()</a>. The same method can also be called to pause or stop the signal generation.</p>
<p>By default all internal channel sync masters are automatically controlled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>integer whose value is <a class="el" href="GEC__ISfpdpRecorder_8h.html#a30e33cb73966e64469d0ee06fcfcee2d">GEC_SFPDP_AUTOMATIC_CONTROL</a> or <a class="el" href="GEC__ISfpdpRecorder_8h.html#a9fc53ab19e2da7d37577ed0739d28aa2">GEC_SFPDP_MANUAL_CONTROL</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value value of <code>mode</code> isn't a valid control mode </dd></dl>

</div>
</div>
<a id="a5124cdb69132a21e7645014b13881701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5124cdb69132a21e7645014b13881701">&#9670;&nbsp;</a></span>setLinkSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setLinkSpeed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the link speed to be used by a session</p>
<p>There are five valid values for the 'speed' parameter. The table below lists the constants that represent these values along with the resulting link speed</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Constant  </th><th class="markdownTableHeadNone">Link speed   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba3fd88de21b7782dd088352f0e7615b43">GEC_SFPDP_1_0625_GBPS</a>  </td><td class="markdownTableBodyNone">1.0625 Gbps   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba26b4918ed013d25b9333cbe08c1dae26">GEC_SFPDP_2_125_GBPS</a>  </td><td class="markdownTableBodyNone">2.125 Gbps   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a06fc87d81c62e9abb8790b6e5713c55babcbd05af8263bfe9d505b285adfa8bdd">GEC_SFPDP_2_5_GBPS</a>  </td><td class="markdownTableBodyNone">2.5 Gbps   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a06fc87d81c62e9abb8790b6e5713c55baad59e868f490482aa83a23e97eafd79a">GEC_SFPDP_3_125_GBPS</a>  </td><td class="markdownTableBodyNone">3.125 Gbps   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="GEC__ISfpdpRecorder_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1176744ac2b0ef382fe43288b6c9187b">GEC_SFPDP_4_25_GBPS</a>  </td><td class="markdownTableBodyNone">4.25 Gbps   </td></tr>
</table>
<p>Note that transmit and receive on a Serial FPDP port share the link speed setting. Therefore playback sessions and recording sessions that use the same Serial FPDP port, will have the same link speed.</p>
<p>This method must be called before the specified session is activated, i.e. before <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> is called. When the speed setting is changed, the link speed is immediately adjusted.</p>
<p>By default a recorder instance will use 2.5Gbps as its link speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a> or <a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open()</a>). </td></tr>
    <tr><td class="paramname">speed</td><td>integer whose value represents a predefined link speed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing session or the value of 'speed' doesn't equal a defined speed constant </dd>
<dd>
GE_NOT_PERMITTED The session is already activated </dd></dl>

</div>
</div>
<a id="a118285ec2027c4ef0a8fc061d3a7cacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118285ec2027c4ef0a8fc061d3a7cacb">&#9670;&nbsp;</a></span>setMaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setMaxSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set maximum number of bytes that can be recorded by in a recording session.</p>
<p>This method will limit the size of the data file. It will not affect the size of the index file.</p>
<p>If the number of recorded bytes in the data file reaches the limit specified by this method, further data will not be appended to the data file.</p>
<p>The <a class="el" href="classGEC__ISfpdpRecorder.html#abb1055aa473a5e0348d3a6cc8856a59e">stopAll()</a> method should be called to free resources, even if the maximum size of the data file has been reached in all recording sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing a recording session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>). </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>64 bit unsigned integer which specifies the maximum number of bytes that will be recorded in the data file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing recording session </dd></dl>

</div>
</div>
<a id="ac3575333a82b60b4bc8a51306ea5a789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3575333a82b60b4bc8a51306ea5a789">&#9670;&nbsp;</a></span>setRateControl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setRateControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cycleSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cyclePartsForTx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set how the recorder will control the rate when transmitting data in a playback session.</p>
<p>The recorder views data flow as a sequence of transmit cycles. The duration of all cycles equals the time to transmit either 512 words, 16K words, 512K words, or 16M words. Each cycle is then divided in 64 parts, and the recorder is only allowed to transmit during a specified number of these parts at the start of each cycle.</p>
<p>The 'cycleSize' parameter specifies the duration of the data cycles. And the 'cyclePartsForTx' specifies the number of 1/64 cycle parts during which data can be transmitted.</p>
<p>To have effect, this method must be called while the recorder instance is inactive (before <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll</a> is called).</p>
<p>By default, rate control is configured to allow transmission of data at full link speed ('cycleSize' is <a class="el" href="GEC__ISfpdpRecorder_8h.html#a22e8c0457a31a091f8c572de6ad15ec1">GEC_SFPDP_16M_WORDS_CYCLE</a> and 'cyclePartsForTx' is 64).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>). </td></tr>
    <tr><td class="paramname">cycleSize</td><td>integer whose value is <a class="el" href="GEC__ISfpdpRecorder_8h.html#a512906ab287b1ebd0e595798d52abbdb">GEC_SFPDP_512_WORDS_CYCLE</a>, <a class="el" href="GEC__ISfpdpRecorder_8h.html#aa86d2a9569d8711a2419384b591b35d6">GEC_SFPDP_16K_WORDS_CYCLE</a>, <a class="el" href="GEC__ISfpdpRecorder_8h.html#a42e44050fc2797d15ad861ba170ad2a9">GEC_SFPDP_512K_WORDS_CYCLE</a>, or <a class="el" href="GEC__ISfpdpRecorder_8h.html#a22e8c0457a31a091f8c572de6ad15ec1">GEC_SFPDP_16M_WORDS_CYCLE</a>. </td></tr>
    <tr><td class="paramname">cyclePartsForTx</td><td>32 bit unsigned integer between 1 and 64, which states how many 1/64 parts of the transmit cycle the recorder is allowed to transmit data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing recorder instance </dd>
<dd>
GE_NOT_PERMITTED The value of 'id' refers to a recording session </dd></dl>

</div>
</div>
<a id="ac0485d7050c4d8425db947c8f306228d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0485d7050c4d8425db947c8f306228d">&#9670;&nbsp;</a></span>setSimplexLinkMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setSimplexLinkMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether simplex link mode is enabled or disabled for a playback session.</p>
<p>When called with the 'enable' parameter equal to 'true', this method enables simplex link mode for the specified session. And when called with the 'enable' parameter equal to false, it disables simplex link mode.</p>
<p>When simplex link mode is enabled, the recorder assumes that the playback session transmits data to a link that only supports outgoing signaling. There is no incoming signaling from the data receiver. More specifically this means that the recorder doesn't receive neither NRDY* signaling nor STOP/GO signaling.</p>
<p>Since there is no NRDY* signaling, the recorder assumes that the receiver is always ready, and data transmission begins immediately, when the playback session is started.</p>
<p>Flow control relies on STOP/GO signaling. So when this signaling is missing, the recorder cannot do flow control. Instead it acts as if GO is always signaled, and the playback session always transmit data at its specified rate.</p>
<p>The effect of this, is that enabling simplex link mode disables flow control regardless of any setting made by <a class="el" href="classGEC__ISfpdpRecorder.html#a2627c35feb86e78dff1a71946cf018c2">setFlowControl</a>.</p>
<p>To have effect, this method must be called while the recorder instance is inactive (before <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll</a> is called).</p>
<p>By default simplex link mode is disabled for playback sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>). </td></tr>
    <tr><td class="paramname">enable</td><td>boolean value which states whether simplex link mode is enabled (true) or disabled (false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing recorder instance </dd>
<dd>
GE_NOT_PERMITTED The value of 'id' refers to a recording session </dd></dl>

</div>
</div>
<a id="a8defdd82514e1012e7beb95e9da33ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8defdd82514e1012e7beb95e9da33ccf">&#9670;&nbsp;</a></span>setSwapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setSwapping </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable8in16</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable16in32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configure swapping inside 32 bit words.</p>
<p>The SFPDP module may perform two kinds of swapping in the 32 bit data words being transmitted or received; 8 bit swapping inside 16 bit and/or 16 bit swapping inside 32 bit.</p>
<p>When only 8 bit swapping inside 16 bit is enabled, each 32 bit data word is regarded as two 16 bit fields, and the most significant byte and least significant byte in these 16 bit values are swapped. The data word 0x12345678 will for example be changed to 0x34127856.</p>
<p>When only 16 bit swapping inside 32 bit is enabled, the 16 most significant bits in each data word are swapped with the 16 least significant bits. Now the data word 0x12345678 will change to 0x56781234.</p>
<p>It is possible use 8 bit swapping inside 16 bit and 16 bit swapping inside 32 bit together. This will in effect reverse the endianness of the received data words, ie the data word 0x12345678 will change to 0x78563412.</p>
<p>By default both 8 bit swapping inside 16 bit and 16 bit swapping inside 32 bit are disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing a recording session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>) or a playback session (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#a7b3e83188a253e7699170c10382a2b8f">open()</a>). </td></tr>
    <tr><td class="paramname">enable8in16</td><td>Boolean value specifiying whether 8 bit swapping inside 16 bit should be enabled (true) or disabled (false) </td></tr>
    <tr><td class="paramname">enable16in32</td><td>Boolean value specifiying whether 16 bit swapping inside 32 bit should be enabled (true) or disabled (false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of <code>id</code> doesn't refer to an existing session </dd></dl>

</div>
</div>
<a id="a2248d5ce7dce0c13c2ea6893b2afd11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2248d5ce7dce0c13c2ea6893b2afd11a">&#9670;&nbsp;</a></span>setWaitForSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::setWaitForSync </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether or not a recording session will wait for a SYNC before starting recording.</p>
<p>When the 'mode' parameter is <a class="el" href="GEC__ISfpdpRecorder_8h.html#ac15f83e3ec24a29586dc554419dca25e">GEC_SFPDP_NO_WAIT_FOR_SYNC</a>, the recorder starts recording on the first data received after <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll()</a> is called.</p>
<p>When 'mode' is set to <a class="el" href="GEC__ISfpdpRecorder_8h.html#a0542f729d2cbe9867dece64134c61d8b">GEC_SFPDP_WAIT_FOR_ANY_SYNC</a>, the recorder discards any data received on the associated Serial FPDP port until SYNC is asserted.</p>
<p>By default a recording session will use GEC_SFPDP_WAIT_FOR_ANY_SYNC as Wait for SYNC mode.</p>
<p>When the recorder is waiting for SYNC, and SYNC is first asserted in a SYNC with Data frame, the data in that frame starts the recording. But if SYNC is first asserted in a SYNC without Data frame, the data in the next frame starts the recording.</p>
<p>This method can only be called for recording sessions (<a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>). It will fail if called for playback sessions.</p>
<p>To have effect, this method must be called while the recording session is inactive (before <a class="el" href="classGEC__ISfpdpRecorder.html#a8f3c66f4c6013aeace6f6f117a9a0329">startAll</a> is called)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>32 bit integer with the unique value representing the recorder instance (returned by <a class="el" href="classGEC__ISfpdpRecorder.html#ad7630972b174f6c4e23e3f2db84cc681">create()</a>). </td></tr>
    <tr><td class="paramname">mode</td><td>integer whose value is <a class="el" href="GEC__ISfpdpRecorder_8h.html#ac15f83e3ec24a29586dc554419dca25e">GEC_SFPDP_NO_WAIT_FOR_SYNC</a> or <a class="el" href="GEC__ISfpdpRecorder_8h.html#a0542f729d2cbe9867dece64134c61d8b">GEC_SFPDP_WAIT_FOR_ANY_SYNC</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd>
<dd>
GE_INVALID_PARAMETER The value of 'id' doesn't refer to an existing session or the value of 'mode' doesn't match a defined mode constant </dd>
<dd>
GE_NOT_PERMITTED The value of 'id' refers to a playback session </dd></dl>

</div>
</div>
<a id="a8f3c66f4c6013aeace6f6f117a9a0329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c66f4c6013aeace6f6f117a9a0329">&#9670;&nbsp;</a></span>startAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::startAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Activate all sessions</p>
<p>Recording is started in all existing recording sessions, and playback is started in all existing playback sessions.</p>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a5">example.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="abb1055aa473a5e0348d3a6cc8856a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1055aa473a5e0348d3a6cc8856a59e">&#9670;&nbsp;</a></span>stopAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int GEC_ISfpdpRecorder::stopAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deactivate all sessions</p>
<p>Recording is stopped in all existing recording sessions, and playback is stopped in all existing playback sessions.</p>
<p>This method should always be called to free resources. This applies even if all sessions stop by themselves (recording sessions because the maximum file size is reached, and playback sessions because they have reached the end of their data files).</p>
<dl class="section return"><dt>Returns</dt><dd>GE_OK Success </dd>
<dd>
GEC_COMMFAIL Communication with remote recorder failed </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#a7">example.cpp</a>.</dd>
</dl>
</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>inc/<a class="el" href="GEC__ISfpdpRecorder_8h_source.html">GEC_ISfpdpRecorder.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
